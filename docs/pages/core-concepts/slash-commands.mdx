---
title: "Slash Commands"
description: "Agentful's command system for controlling autonomous development"
sidebar_position: 4
---

# Slash Commands

Slash commands are your **control interface for Agentful** - simple, human-readable commands that trigger complex autonomous workflows. Think of them as the steering wheel, accelerator, and dashboard for autonomous development.

## What Are Slash Commands?

Slash commands are defined in `.claude/commands/` as markdown files with frontmatter:

```markdown
---
name: agentful-start
description: Start or resume autonomous product development loop
---

# Agentful Start

This command initiates the autonomous product development loop.
```

When you type `/agentful-start`, Claude Code reads the command definition and executes the workflow described within it.

## Why Slash Commands?

### The Problem with "Just Talk to AI"

Without structured commands:
```
You: "Start working on my project"

AI: "What should I build?"
You: "It's in PRODUCT.md"
AI: "Ok, what should I do first?"
You: "I don't know, you decide"
AI: "Should I build the frontend or backend?"
You: "I don't care, just start"
[...conversation continues for 10 minutes...]
```

### The Agentful Solution

With slash commands:
```
You: /agentful-start

Agentful: [Immediately reads state, picks task, delegates, validates]
         ‚Üí No questions
         ‚Üí No ambiguity
         ‚Üí Immediate action
```

### Benefits

| Benefit | Description |
|---------|-------------|
| **Consistency** | Same command, same behavior, every time |
| **Speed** | No conversational overhead |
| **Discoverable** | Tab-completion shows all commands |
| **Composable** | Commands can call other commands |
| **Traceable** | Clear audit trail of what was run |
| **Parameterizable** | Pass flags and options |

## The Four Core Commands

Agentful has four primary commands for autonomous development:

### 1. `/agentful-start` - The Engine Starter

**Purpose:** Start or resume autonomous product development loop

**What it does:**
```bash
1. Load State
   - Read PRODUCT.md (what we're building)
   - Read .agentful/state.json (current work state)
   - Read .agentful/completion.json (progress)
   - Read .agentful/decisions.json (pending decisions)

2. Check Blockers
   - If decisions pending ‚Üí Warn user
   - Continue with unblocked work

3. Initialize State (if needed)
   - Create .agentful/state.json if missing
   - Set current_phase = "idle"

4. Delegate to Orchestrator
   - Task("orchestrator", "Run autonomous development loop")
   - Orchestrator picks next task
   - Delegates to specialists
   - Validates results
   - Updates progress
   - Loops until complete
```

**Usage:**
```bash
# Manual mode (one task at a time)
/agentful-start

# Continuous mode (24/7 development)
/ralph-loop "/agentful-start" --max-iterations 50 --completion-promise "AGENTFUL_COMPLETE"
```

**When to use:**
- First time starting development
- After resolving decisions
- After manual intervention
- To check progress while continuing

**Output:**
```
Agentful: Starting autonomous development loop...

  ‚Üí Detected Next.js + TypeScript + Prisma + Tailwind
  ‚Üí Reading state: auth = 30% complete
  ‚Üí Next task: Complete auth frontend
  ‚Üí Delegating to @frontend agent...

[Agent completes work]

  ‚Üí Validating changes...
     TypeScript: ‚úÖ
     Lint: ‚úÖ
     Tests: ‚úÖ
     Coverage: 85% ‚úÖ
  ‚Üí Auth = 100% complete
  ‚Üí Next: User profile feature
```

### 2. `/agentful-status` - The Dashboard

**Purpose:** Show current progress, completion percentage, and what's being worked on

**What it does:**
```bash
1. Read state files
   - state.json (current work, phase, iterations)
   - completion.json (features, gates)
   - decisions.json (pending decisions)
   - PRODUCT.md (product name)

2. Format output beautifully
   - ASCII art tables
   - Progress bars
   - Status indicators
   - Quick action suggestions

3. Display:
   - Overall completion percentage
   - Feature-by-feature status
   - Quality gate status
   - Pending decisions
   - Current work
```

**Usage:**
```bash
/agentful-status
```

**Output:**
```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
           Agentful Development Status
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Product: Task Management App
Overall Progress: ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 48%
Phase: implementing
Iterations: 12

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Feature             ‚îÇ Status   ‚îÇ Score   ‚îÇ Notes          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Authentication      ‚îÇ ‚úÖ Done  ‚îÇ 100%    ‚îÇ                ‚îÇ
‚îÇ User Profile        ‚îÇ üîÑ Active‚îÇ 45%     ‚îÇ Backend done   ‚îÇ
‚îÇ Dashboard           ‚îÇ ‚è∏ Pending‚îÇ 0%      ‚îÇ Blocked on UX  ‚îÇ
‚îÇ Settings            ‚îÇ ‚è∏ Pending‚îÇ 0%      ‚îÇ                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Quality Gate        ‚îÇ Status ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Tests Passing       ‚îÇ ‚úÖ     ‚îÇ
‚îÇ No Type Errors      ‚îÇ ‚úÖ     ‚îÇ
‚îÇ No Dead Code        ‚îÇ ‚ùå     ‚îÇ
‚îÇ Coverage ‚â• 80%      ‚îÇ ‚ö†Ô∏è 72% ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚ö†Ô∏è  Decisions Needed:

1. "Should dashboard use grid or list layout?"
   Blocking: dashboard-feature
   ‚Üí Run /agentful-decide to resolve

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Next Actions:
  ‚Ä¢ /agentful-start    - Continue development
  ‚Ä¢ /agentful-decide  - Answer pending decisions
  ‚Ä¢ /agentful-validate- Run quality checks
```

**When to use:**
- Check progress without continuing work
- See what's blocking development
- Get a quick overview
- Before making decisions

### 3. `/agentful-decide` - The Decision Resolver

**Purpose:** Answer pending decisions that are blocking development progress

**What it does:**
```bash
1. Read decisions.json
   - Get list of pending decisions
   - Each has: question, options, context, blocking

2. Present to user interactively
   - Use AskUserQuestion tool
   - Show question, options, context
   - Accept user selection

3. Record decision
   - Move from pending to resolved
   - Store answer with timestamp

4. Update state
   - Remove from state.json blocked_on array
   - Allow blocked features to proceed

5. Show summary
   - What was resolved
   - What's now unblocked
```

**Usage:**
```bash
/agentful-decide
```

**Output:**
```
‚ö†Ô∏è  You have 2 pending decisions:

[1/2] Should auth use JWT or session cookies?

    Context: Building authentication system
    Blocking: auth-feature, user-profile-feature

    Options:
      [1] JWT (stateless, scalable)
      [2] Sessions (simpler, built-in)
      [3] Clerk (managed service)

    Your choice: > 1

[2/2] Which database provider?

    Context: Need database for user data
    Blocking: database-setup

    Options:
      [1] PostgreSQL (robust, scalable)
      [2] MySQL (widely supported)
      [3] SQLite (simple, file-based)
      [4] MongoDB (NoSQL, flexible)

    Your choice: > 1

‚úÖ All decisions resolved!

Unblocked features:
  - auth-feature (can now proceed)
  - user-profile-feature (can now proceed)
  - database-setup (can now proceed)

Run /agentful-start to continue development.
```

**When to use:**
- When status shows pending decisions
- Before continuing development
- To unblock features
- To provide technical direction

### 4. `/agentful-validate` - The Quality Check

**Purpose:** Run all quality checks and validation gates

**What it does:**
```bash
1. Delegate to reviewer agent
   - Task("reviewer", "Run all validation checks")

2. Reviewer runs 8 checks:
   - TypeScript (npx tsc --noEmit)
   - Lint (npm run lint)
   - Dead code detection
   - Tests (npm test)
   - Coverage (‚â• 80%)
   - Security (secrets, vulnerabilities, logs)
   - Manual code review
   - Console log check

3. Display results
   - Pass/fail for each check
   - List of issues found
   - Suggestions for fixing

4. Update completion.json
   - Set gate statuses
   - Track what's passing/failing

5. Offer auto-fix
   - Ask if user wants to run fixer
```

**Usage:**
```bash
# Full validation
/agentful-validate

# Quick checks (with flags)
/agentful-validate --type-check
/agentful-validate --tests
/agentful-validate --security
```

**Output:**
```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
              Validation Results
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

TypeScript      ‚úÖ PASS - No type errors
Lint            ‚úÖ PASS - No lint errors
Dead Code       ‚ùå FAIL - 3 issues found
Tests           ‚úÖ PASS - 47 tests passed
Coverage        ‚ö†Ô∏è  WARN - 72% (needs 80%)
Security        ‚ö†Ô∏è  WARN - 2 issues found

Overall: ‚ùå FAILED
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Issues that must be fixed:

1. [Dead Code] Unused export: formatDate in src/utils/date.ts
2. [Dead Code] Unused file: src/components/OldWidget.tsx
3. [Dead Code] Unused dependency: lodash in package.json
4. [Coverage] 8 percentage points below threshold (72% vs 80%)
5. [Security] console.log in src/auth/login.ts:45

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Would you like to auto-fix these issues? [y/N]: > y

Delegating to @fixer agent...

[Fixer removes dead code, adds tests, removes console.log]

Re-validating...
TypeScript      ‚úÖ PASS
Lint            ‚úÖ PASS
Dead Code       ‚úÖ PASS
Tests           ‚úÖ PASS
Coverage        ‚úÖ PASS - 82%
Security        ‚úÖ PASS

Overall: ‚úÖ ALL CHECKS PASSED
```

**When to use:**
- After manual code changes
- Before committing
- To check code quality
- To see what needs fixing
- In CI/CD pipelines

## Command Architecture

### Command Structure

Each command is a markdown file with:

```markdown
---
name: command-name
description: Human-readable description
---

# Command Name

This command does X, Y, Z.

## Process

Step-by-step instructions...

## Implementation

Detailed steps...

## Example Flow

Example usage...
```

### Command Communication

Commands communicate through:

1. **State files** - Read `.agentful/*.json`
2. **Agent delegation** - Use Task tool to spawn agents
3. **Tool execution** - Run Bash, Read, Write, etc.

Example command that delegates:
```markdown
## Process

### 1. Run Reviewer
```
Task("reviewer", "Run all validation checks on the current codebase and report results.")
```

### 2. Display Results
After reviewer completes, display formatted output...
```

## Command Composition

Commands can call other commands:

```markdown
# In agentful-start.md

## Process

### If pending decisions found
```
User needs to resolve decisions first.

‚Üí Run: /agentful-decide
```
```

## Command Best Practices

### DO ‚úÖ

- **Be specific** - Clear descriptions of what command does
- **Check state** - Always read state files first
- **Delegate appropriately** - Use Task tool for agents
- **Format output** - Make it readable (tables, progress bars)
- **Handle errors** - Graceful failure with helpful messages
- **Suggest next actions** - Guide user on what to do next

### DON'T ‚ùå

- **Don't implement directly** - Delegate to agents
- **Don't skip state checks** - Always read state files
- **Don't hardcode paths** - Use relative or detected paths
- **Don't assume** - Check files exist before reading
- **Don't be silent** - Always provide feedback

## Creating Custom Commands

You can add your own commands in `.claude/commands/`:

```markdown
---
name: agentful-deploy
description: Deploy to production after all validations pass
---

# Agentful Deploy

This command deploys your application to production.

## Preconditions

Check all gates first:
```bash
# Delegate to validate
Task("reviewer", "Run all validation checks")
```

If any checks fail:
```
‚ùå Cannot deploy: Quality gates not passing
Run /agentful-validate to see issues
```

## Deployment Process

1. Run tests
2. Build application
3. Deploy to production (Vercel/Netlify/etc.)
4. Verify deployment
5. Tag release
```

Then use it:
```bash
/agentful-deploy
```

## Command Reference Summary

| Command | Purpose | When to Use |
|---------|---------|-------------|
| `/agentful-start` | Start/resume autonomous development | Always (primary command) |
| `/agentful-status` | Show progress and state | Checking progress |
| `/agentful-decide` | Resolve pending decisions | When blocked |
| `/agentful-validate` | Run quality checks | After manual changes |

## Command Flow Examples

### Typical Development Session

```bash
# Start development
/agentful-start

[Works for 30 minutes, completes 3 features]

# Check progress
/agentful-status

# See a decision is needed, resolve it
/agentful-decide

# Continue development
/agentful-start

[Works for 20 minutes, then blocked by decision]

[You make some manual code changes]

# Validate your changes
/agentful-validate

# Continue autonomous development
/agentful-start
```

### 24/7 Development

```bash
# Start continuous mode
/ralph-loop "/agentful-start" --max-iterations 50

# Check in anytime
/agentful-status

# If stuck on decisions
/agentful-decide

# Loop resumes automatically
```

## Summary

Slash commands are your interface to Agentful:

- **Simple** - One command triggers complex workflows
- **Consistent** - Same behavior every time
- **Composable** - Commands can call other commands
- **Traceable** - Clear audit trail
- **Extensible** - Add your own commands

They transform autonomous development from a conversation into a **controlled, observable process**.

**Next:** [Learn about skills](./skills)
