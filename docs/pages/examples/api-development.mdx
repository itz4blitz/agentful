---
title: REST API Service - Complete Example
description: Build a production-ready Express API with clean architecture, comprehensive testing, and API documentation
---

# REST API Service

A production-ready REST API for an e-commerce platform with user management, product catalog, order processing, and comprehensive testing.

---

## Overview

**ShopAPI** is a backend-only REST API service that powers e-commerce applications. Built with Node.js, Express, and TypeScript, following clean architecture principles with comprehensive testing and documentation.

### Business Value
- **Target Users**: E-commerce platforms, marketplaces, online stores
- **Key Problem**: Need a scalable, well-tested backend for online sales
- **Solution**: RESTful API with clean architecture and 90%+ test coverage

### Key Features
- ✅ Clean architecture (Repository → Service → Controller)
- ✅ JWT authentication with role-based access
- ✅ Product catalog with categories and search
- ✅ Order processing with status tracking
- ✅ Input validation with Zod schemas
- ✅ API documentation with Swagger
- ✅ Comprehensive error handling
- ✅ 90% test coverage
- ✅ Rate limiting and security

---

## Complete PRODUCT.md

```markdown
# ShopAPI - E-commerce REST API

## Overview
A production-ready REST API for e-commerce platforms. Provides endpoints for user management, product catalog, order processing, and payment integration. Built with clean architecture patterns and comprehensive testing.

## Tech Stack
- **Runtime**: Node.js 20 LTS
- **Framework**: Express.js 4.x
- **Language**: TypeScript 5.x (strict mode)
- **Database**: PostgreSQL 15
- **ORM**: Prisma 5.x
- **Authentication**: JWT (jsonwebtoken)
- **Validation**: Zod 3.x
- **Testing**: Jest 29.x, Supertest
- **Documentation**: Swagger/OpenAPI 3.0
- **Security**: Helmet, CORS, express-rate-limit
- **Code Quality**: ESLint, Prettier

## Features

<FEATURE_ORGANIZATION NOTE>
This API demonstrates HIERARCHICAL structure optimized for REST services.
Features organized by API resource domain:
- .claude/product/domains/users/
- .claude/product/domains/products/
- .claude/product/domains/orders/
This mirrors REST resource organization and scales for large APIs.
</FEATURE_ORGANIZATION NOTE>

### Domain: Users

#### User Registration - CRITICAL
**Priority**: CRITICAL
**Description**: Register new customer accounts
**User Stories**:
- As a new user, I can register an account with email and password
**Acceptance Criteria**:
- Passwords hashed with bcrypt (10 rounds)
- Email must be unique
- Default role: Customer
- Returns JWT token on successful registration
**API Endpoint**:
- POST /api/auth/register
**Implementation**:
- Repository: UserRepository
- Service: AuthService.register()
- Controller: AuthController.register()
- Validation: registerSchema
- Middleware: None (public endpoint)

#### User Login - CRITICAL
**Priority**: CRITICAL
**Description**: Authenticate users and issue JWT tokens
**User Stories**:
- As a registered user, I can login to receive a JWT token
- As an authenticated user, I can access protected endpoints
- As an admin, I have elevated permissions
**Acceptance Criteria**:
- JWT tokens expire after 24 hours
- Refresh tokens available (7 days)
- Roles: Customer, Admin, SuperAdmin
- Protected routes require valid JWT in Authorization header
**API Endpoints**:
- POST /api/auth/login
- POST /api/auth/refresh
**Implementation**:
- Repository: UserRepository
- Service: AuthService.login()
- Controller: AuthController.login()
- Validation: loginSchema
- Middleware: authMiddleware (for protected routes)

#### User Logout - MEDIUM
**Priority**: MEDIUM
**Description**: Invalidate user tokens
**User Stories**:
- As a logged-in user, I can logout securely
**Acceptance Criteria**:
- Add token to blacklist (or use short-lived tokens)
- Clear client-side token storage
**API Endpoint**:
- POST /api/auth/logout
**Implementation**:
- Service: AuthService.logout()
- Controller: AuthController.logout()

#### View Profile - MEDIUM
**Priority**: MEDIUM
**Description**: Users can view their profile information
**User Stories**:
- As a user, I can view my profile information
**Acceptance Criteria**:
- Returns user's name, email, role
- Requires authentication
**API Endpoint**:
- GET /api/users/me
**Implementation**:
- Repository: UserRepository
- Service: UserService.getProfile()
- Controller: UserController.getProfile()
- Middleware: authMiddleware

#### Update Profile - LOW
**Priority**: LOW
**Description**: Users can update their account details
**User Stories**:
- As a user, I can update my name and email
**Acceptance Criteria**:
- Users can update name and email
- Email changes require verification
- Email must remain unique
**API Endpoint**:
- PUT /api/users/me
**Implementation**:
- Repository: UserRepository
- Service: UserService.updateProfile()
- Controller: UserController.updateProfile()
- Validation: updateProfileSchema
- Middleware: authMiddleware

#### Admin: List All Users - LOW
**Priority**: LOW
**Description**: Admin can view all user accounts
**User Stories**:
- As an admin, I can view all user accounts with pagination
**Acceptance Criteria**:
- Admin can list all users with pagination
- Shows email, name, role, created date
- Requires Admin or SuperAdmin role
**API Endpoint**:
- GET /api/admin/users
**Implementation**:
- Repository: UserRepository
- Service: UserService.listUsers()
- Controller: UserController.listUsers()
- Middleware: authMiddleware, roleMiddleware(['ADMIN', 'SUPERADMIN'])

#### Admin: Delete User - LOW
**Priority**: LOW
**Description**: Admin can delete user accounts
**User Stories**:
- As an admin, I can delete user accounts
**Acceptance Criteria**:
- Soft delete for user accounts
- Requires Admin or SuperAdmin role
**API Endpoint**:
- DELETE /api/admin/users/:id
**Implementation**:
- Repository: UserRepository
- Service: UserService.deleteUser()
- Controller: UserController.deleteUser()
- Middleware: authMiddleware, roleMiddleware(['ADMIN', 'SUPERADMIN'])

### Domain: Products

#### List Products - HIGH
**Priority**: HIGH
**Description**: Browse and filter product catalog
**User Stories**:
- As a customer, I can browse all products
- As a customer, I can search products by name
- As a customer, I can filter products by category and price
**Acceptance Criteria**:
- Products have name, description, price, stock, category
- Pagination support (default 20 per page, max 100)
- Full-text search on name and description
- Category filtering
- Price range filtering (minPrice, maxPrice)
- Sorting by price, name, createdAt
**API Endpoints**:
- GET /api/products (list with filters)
- GET /api/products/search/:query
**Implementation**:
- Repository: ProductRepository
- Service: ProductService.getProducts()
- Controller: ProductController.getProducts()
- Validation: productQuerySchema
- Performance: Indexed database queries

#### Get Product Details - HIGH
**Priority**: HIGH
**Description**: View detailed information for a single product
**User Stories**:
- As a customer, I can view detailed product information
**Acceptance Criteria**:
- Returns product with category details
- 404 if product not found
**API Endpoint**:
- GET /api/products/:id
**Implementation**:
- Repository: ProductRepository
- Service: ProductService.getProductById()
- Controller: ProductController.getProductById()

#### Admin: Create Product - HIGH
**Priority**: HIGH
**Description**: Admin can add new products to catalog
**User Stories**:
- As an admin, I can create new products
**Acceptance Criteria**:
- Requires Admin or SuperAdmin role
- Stock validation (cannot be negative)
- Price must be positive
- Category must exist
**API Endpoint**:
- POST /api/products
**Implementation**:
- Repository: ProductRepository, CategoryRepository
- Service: ProductService.createProduct()
- Controller: ProductController.createProduct()
- Validation: productSchema
- Middleware: authMiddleware, roleMiddleware(['ADMIN', 'SUPERADMIN'])

#### Admin: Update Product - HIGH
**Priority**: HIGH
**Description**: Admin can modify product information
**User Stories**:
- As an admin, I can update product details
**Acceptance Criteria**:
- Requires Admin or SuperAdmin role
- Same validation as create
**API Endpoint**:
- PUT /api/products/:id
**Implementation**:
- Repository: ProductRepository, CategoryRepository
- Service: ProductService.updateProduct()
- Controller: ProductController.updateProduct()
- Validation: productSchema
- Middleware: authMiddleware, roleMiddleware(['ADMIN', 'SUPERADMIN'])

#### Admin: Delete Product - MEDIUM
**Priority**: MEDIUM
**Description**: Admin can remove products from catalog
**User Stories**:
- As an admin, I can delete products
**Acceptance Criteria**:
- Requires Admin or SuperAdmin role
- Check if product is referenced in orders (optionally prevent)
**API Endpoint**:
- DELETE /api/products/:id
**Implementation**:
- Repository: ProductRepository
- Service: ProductService.deleteProduct()
- Controller: ProductController.deleteProduct()
- Middleware: authMiddleware, roleMiddleware(['ADMIN', 'SUPERADMIN'])

#### List Categories - MEDIUM
**Priority**: MEDIUM
**Description**: View all product categories
**User Stories**:
- As a customer, I can browse products by category
**Acceptance Criteria**:
- Returns flat list or nested structure
- Includes product count per category
**API Endpoint**:
- GET /api/categories
**Implementation**:
- Repository: CategoryRepository
- Service: CategoryService.getCategories()
- Controller: CategoryController.getCategories()

#### Admin: Create Category - MEDIUM
**Priority**: MEDIUM
**Description**: Admin can create product categories
**User Stories**:
- As an admin, I can create product categories
**Acceptance Criteria**:
- Requires Admin or SuperAdmin role
- Categories have name, description, parent category (optional)
- Support nested categories (max 2 levels)
- Soft delete for categories
**API Endpoint**:
- POST /api/categories
**Implementation**:
- Repository: CategoryRepository
- Service: CategoryService.createCategory()
- Controller: CategoryController.createCategory()
- Validation: categorySchema
- Middleware: authMiddleware, roleMiddleware(['ADMIN', 'SUPERADMIN'])

#### Admin: Update Category - MEDIUM
**Priority**: MEDIUM
**Description**: Admin can modify category details
**User Stories**:
- As an admin, I can update category details
**Acceptance Criteria**:
- Requires Admin or SuperAdmin role
**Cannot create circular references in parent category
**API Endpoint**:
- PUT /api/categories/:id
**Implementation**:
- Repository: CategoryRepository
- Service: CategoryService.updateCategory()
- Controller: CategoryController.updateCategory()
- Validation: categorySchema
- Middleware: authMiddleware, roleMiddleware(['ADMIN', 'SUPERADMIN'])

#### Admin: Delete Category - LOW
**Priority**: LOW
**Description**: Admin can remove categories
**User Stories**:
- As an admin, I can delete categories
**Acceptance Criteria**:
- Requires Admin or SuperAdmin role
- Soft delete
- Cannot delete if products reference it
**API Endpoint**:
- DELETE /api/categories/:id
**Implementation**:
- Repository: CategoryRepository
- Service: CategoryService.deleteCategory()
- Controller: CategoryController.deleteCategory()
- Middleware: authMiddleware, roleMiddleware(['ADMIN', 'SUPERADMIN'])

### Domain: Orders

#### Create Order - HIGH
**Priority**: HIGH
**Description**: Customers can create orders with multiple items
**User Stories**:
- As a customer, I can create an order with multiple items
**Acceptance Criteria**:
- Orders have multiple items (quantity, price at purchase)
- Stock validation before order creation
- Order total calculation
- Atomic transaction (all items succeed or all fail)
**API Endpoint**:
- POST /api/orders
**Implementation**:
- Repository: OrderRepository, OrderItemRepository, ProductRepository
- Service: OrderService.createOrder()
- Controller: OrderController.createOrder()
- Validation: createOrderSchema
- Business Logic: Transaction handling for stock updates
- Middleware: authMiddleware

#### View My Orders - HIGH
**Priority**: HIGH
**Description**: Customers can view their order history
**User Stories**:
- As a customer, I can view my order history
**Acceptance Criteria**:
- Customer can only see their own orders
- Pagination support
- Ordered by date descending
**API Endpoint**:
- GET /api/orders
**Implementation**:
- Repository: OrderRepository
- Service: OrderService.getCustomerOrders()
- Controller: OrderController.getCustomerOrders()
- Middleware: authMiddleware

#### View Order Details - HIGH
**Priority**: HIGH
**Description**: View detailed information for a specific order
**User Stories**:
- As a customer, I can view detailed order information
**Acceptance Criteria**:
- Customer can only view their own orders
- Includes all order items with product details
**API Endpoint**:
- GET /api/orders/:id
**Implementation**:
- Repository: OrderRepository
- Service: OrderService.getOrderById()
- Controller: OrderController.getOrderById()
- Middleware: authMiddleware

#### Admin: List All Orders - MEDIUM
**Priority**: MEDIUM
**Description**: Admin can view all orders
**User Stories**:
- As an admin, I can view all orders
**Acceptance Criteria**:
- Requires Admin or SuperAdmin role
- Filter by status, customer, date range
- Pagination support
**API Endpoint**:
- GET /api/admin/orders
**Implementation**:
- Repository: OrderRepository
- Service: OrderService.getAllOrders()
- Controller: OrderController.getAllOrders()
- Middleware: authMiddleware, roleMiddleware(['ADMIN', 'SUPERADMIN'])

#### Admin: Update Order Status - MEDIUM
**Priority**: MEDIUM
**Description**: Admin can update order status
**User Stories**:
- As an admin, I can update order status
**Acceptance Criteria**:
- Requires Admin or SuperAdmin role
- Order status: Pending, Processing, Shipped, Delivered, Cancelled
- Status transition validation
**API Endpoint**:
- PATCH /api/admin/orders/:id/status
**Implementation**:
- Repository: OrderRepository
- Service: OrderService.updateOrderStatus()
- Controller: OrderController.updateOrderStatus()
- Validation: updateOrderStatusSchema
- Middleware: authMiddleware, roleMiddleware(['ADMIN', 'SUPERADMIN'])

#### Process Payment - LOW
**Priority**: LOW
**Description**: Integrate payment processing (placeholder)
**User Stories**:
- As a customer, I can add payment info to orders
**Acceptance Criteria**:
- Support for Stripe/PayPal integration
- Payment status tracking
- Webhook handling for payment updates
**API Endpoints**:
- POST /api/orders/:id/payment
- POST /api/webhooks/payments
**Implementation**:
- Service: PaymentService (adapter pattern)
- Controller: PaymentController
- Validation: paymentSchema

#### Process Refund - LOW
**Priority**: LOW
**Description**: Admin can process refunds
**User Stories**:
- As an admin, I can process refunds
**Acceptance Criteria**:
- Requires Admin or SuperAdmin role
- Restores stock if applicable
**API Endpoint**:
- POST /api/orders/:id/refund
**Implementation**:
- Service: PaymentService
- Controller: PaymentController
- Middleware: authMiddleware, roleMiddleware(['ADMIN', 'SUPERADMIN'])

### Domain: Developer Experience

#### API Documentation - MEDIUM
**Priority**: MEDIUM
**Description**: Self-documenting API with Swagger
**User Stories**:
- As a developer, I can view API documentation at /api-docs
- As a developer, I can try endpoints directly from docs
**Acceptance Criteria**:
- All endpoints documented with OpenAPI 3.0
- Request/response schemas shown
- Authentication examples provided
- Error responses documented
**Implementation**:
- Swagger UI middleware
- JSDoc comments for routes
- YAML/OpenAPI spec file

## Non-Functional Requirements

### Performance
- API response time < 100ms (p95) for simple queries
- Support 1000+ concurrent requests
- Database connection pooling (max 10 connections)
- Redis caching for product listings (optional)

### Security
- Helmet middleware for security headers
- CORS configured for specific origins
- Rate limiting: 100 requests per 15 minutes per IP
- Input sanitization (Zod validation)
- SQL injection prevention (Prisma)
- XSS prevention
- File upload limits (1MB max)
- Environment variable validation

### Reliability
- Graceful error handling
- Proper HTTP status codes
- Request logging (morgan)
- Health check endpoint
- Database transaction rollback on errors
- No sensitive data in logs

### Maintainability
- Clean architecture (layers separation)
- Dependency injection pattern
- Interface-based repositories
- Comprehensive test coverage (≥80%)
- ESLint and Prettier configured
- Meaningful error messages

## Database Schema

```prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String
  name      String
  role      UserRole @default(CUSTOMER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orders Order[]
}

model Category {
  id          String    @id @default(cuid())
  name        String    @unique
  description String?
  parentId    String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  parent   Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id], onDelete: SetNull)
  children Category[] @relation("CategoryHierarchy")
  products Product[]
}

model Product {
  id          String     @id @default(cuid())
  name        String
  description String?
  price       Decimal    @db.Decimal(10, 2)
  stock       Int        @default(0)
  categoryId  String
  images      String[]   @default([])
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  category   Category    @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  orderItems OrderItem[]
}

model Order {
  id         String      @id @default(cuid())
  userId     String
  status     OrderStatus @default(PENDING)
  total      Decimal     @db.Decimal(10, 2)
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt

  user  User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  items OrderItem[]
}

model OrderItem {
  id        String  @id @default(cuid())
  orderId   String
  productId String
  quantity  Int
  price     Decimal @db.Decimal(10, 2)

  order   Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Restrict)

  @@unique([orderId, productId])
}

enum UserRole {
  CUSTOMER
  ADMIN
  SUPERADMIN
}

enum OrderStatus {
  PENDING
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
}
```

## API Documentation Structure

### Base URL
```
Development: http://localhost:3000/api
Production: https://api.shopapi.com/v1
```

### Authentication
Most endpoints require JWT token in Authorization header:
```
Authorization: Bearer <token>
```

### Response Format
Success:
```json
{
  "success": true,
  "data": { ... }
}
```

Error:
```json
{
  "success": false,
  "error": {
    "message": "Error description",
    "code": "ERROR_CODE"
  }
}
```

## Success Criteria

1. All CRITICAL and HIGH priority features implemented
2. All endpoints documented with Swagger
3. Test coverage ≥ 80%
4. All endpoints return proper HTTP status codes
5. Rate limiting configured and tested
6. Security audit passed (no vulnerabilities)
7. API response time < 100ms (p95)
8. Health check endpoint functional

## Notes
- Follow repository → service → controller pattern strictly
- All async errors must be handled
- Use Prisma transactions for multi-step operations
- Log all API requests with morgan
- Validate all inputs with Zod schemas
- Write tests before implementation (TDD preferred)
- Document complex business logic with comments
```

---

## Project Structure

### Initial State

```
shopapi/
├── package.json
└── tsconfig.json
```

### Final State

**Hierarchical PRODUCT.md Structure**:
```
shopapi/
├── .claude/
│   ├── agents/
│   ├── commands/
│   ├── skills/
│   └── product/
│       ├── overview.md          # Project overview, tech stack
│       ├── domains/             # HIERARCHICAL: Organized by API resource
│       │   ├── users/
│       │   │   ├── index.md     # Users domain overview
│       │   │   ├── registration.md
│       │   │   ├── login.md
│       │   │   ├── logout.md
│       │   │   ├── view-profile.md
│       │   │   ├── update-profile.md
│       │   │   ├── list-users.md
│       │   │   └── delete-user.md
│       │   ├── products/
│       │   │   ├── index.md     # Products domain overview
│       │   │   ├── list-products.md
│       │   │   ├── get-product.md
│       │   │   ├── create-product.md
│       │   │   ├── update-product.md
│       │   │   ├── delete-product.md
│       │   │   ├── list-categories.md
│       │   │   ├── create-category.md
│       │   │   ├── update-category.md
│       │   │   └── delete-category.md
│       │   ├── orders/
│       │   │   ├── index.md     # Orders domain overview
│       │   │   ├── create-order.md
│       │   │   ├── view-orders.md
│       │   │   ├── view-order-details.md
│       │   │   ├── list-all-orders.md
│       │   │   ├── update-status.md
│       │   │   ├── process-payment.md
│       │   │   └── process-refund.md
│       │   └── developer-experience/
│       │       └── api-documentation.md
│       ├── non-functional.md    # Performance, security, etc.
│       └── database-schema.md   # Prisma schema
├── .agentful/
│   ├── state.json
│   ├── completion.json
│   └── decisions.json
├── CLAUDE.md
├── prisma/
│   ├── schema.prisma
│   └── migrations/
│       └── 20240118_init/
│           └── migration.sql
├── src/
│   ├── index.ts                 # App entry point
│   ├── app.ts                   # Express app setup
│   ├── config/
│   │   ├── database.ts          # Prisma client
│   │   ├── jwt.ts               # JWT config
│   │   └── rate-limit.ts        # Rate limiting config
│   ├── controllers/             # Request handlers
│   │   ├── auth.controller.ts
│   │   ├── user.controller.ts
│   │   ├── product.controller.ts
│   │   ├── category.controller.ts
│   │   ├── order.controller.ts
│   │   └── payment.controller.ts
│   ├── services/                # Business logic
│   │   ├── auth.service.ts
│   │   ├── user.service.ts
│   │   ├── product.service.ts
│   │   ├── category.service.ts
│   │   ├── order.service.ts
│   │   └── payment.service.ts
│   ├── repositories/            # Data access
│   │   ├── user.repository.ts
│   │   ├── product.repository.ts
│   │   ├── category.repository.ts
│   │   ├── order.repository.ts
│   │   └── order-item.repository.ts
│   ├── middleware/              # Express middleware
│   │   ├── auth.middleware.ts
│   │   ├── role.middleware.ts
│   │   ├── error.middleware.ts
│   │   └── validation.middleware.ts
│   ├── routes/                  # Route definitions
│   │   ├── index.ts
│   │   ├── auth.routes.ts
│   │   ├── user.routes.ts
│   │   ├── product.routes.ts
│   │   ├── category.routes.ts
│   │   ├── order.routes.ts
│   │   └── payment.routes.ts
│   ├── schemas/                 # Zod validation schemas
│   │   ├── auth.schema.ts
│   │   ├── user.schema.ts
│   │   ├── product.schema.ts
│   │   ├── category.schema.ts
│   │   ├── order.schema.ts
│   │   └── payment.schema.ts
│   ├── types/                   # TypeScript types
│   │   ├── auth.types.ts
│   │   ├── user.types.ts
│   │   ├── product.types.ts
│   │   ├── order.types.ts
│   │   └── express.d.ts         # Extended Express types
│   ├── utils/                   # Utility functions
│   │   ├── logger.ts
│   │   ├── error.ts             # Custom error classes
│   │   └── async-handler.ts     # Async error wrapper
│   └── constants/
│       ├── http-status.ts       # HTTP status codes
│       └── error-codes.ts       # Error code constants
├── tests/
│   ├── unit/
│   │   ├── services/
│   │   │   ├── auth.service.test.ts
│   │   │   ├── user.service.test.ts
│   │   │   ├── product.service.test.ts
│   │   │   ├── order.service.test.ts
│   │   │   └── payment.service.test.ts
│   │   └── repositories/
│   │       └── product.repository.test.ts
│   ├── integration/
│   │   ├── api/
│   │   │   ├── auth.test.ts
│   │   │   ├── users.test.ts
│   │   │   ├── products.test.ts
│   │   │   ├── orders.test.ts
│   │   │   └── payments.test.ts
│   │   └── database/
│   │       └── transactions.test.ts
│   └── fixtures/
│       ├── test-data.ts         # Test data factories
│       └── setup.ts             # Test setup/teardown
├── docs/
│   └── swagger.json             # OpenAPI specification
├── .env.example
├── .env.test
├── .eslintrc.js
├── .prettierrc
├── jest.config.js
├── package.json
└── tsconfig.json
```

**Why Hierarchical for APIs?**
For REST APIs, organizing features by resource domain (users, products, orders) is ideal:
- Mirrors REST resource organization
- Each domain = logical API resource group
- Easy to assign different teams to different resources
- Scales to dozens of endpoints without confusion
- Clear separation of concerns (e.g., user domain handles all /api/users/* endpoints)

**File Count**: 87 files
**Lines of Code**: ~6,200 lines
**Test Coverage**: 91%

---

## Implementation Details

## Phase 1: Project Setup



### Phase 1: Project Setup (20 minutes)

#### Initialize Project

```bash
mkdir shopapi && cd shopapi
npm init -y

# Install core dependencies
npm install express cors helmet morgan dotenv
npm install prisma @prisma/client
npm install jsonwebtoken bcryptjs zod

# Install dev dependencies
npm install -D typescript @types/node @types/express
npm install -D @types/cors @types/jsonwebtoken @types/bcryptjs
npm install -D ts-node nodemon jest ts-jest
npm install -D @types/jest supertest
npm install -D eslint prettier

# Initialize TypeScript
npx tsc --init

# Initialize agentful
npx @itz4blitz/agentful init
```

#### Configure TypeScript

**tsconfig.json**:
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "commonjs",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "node",
    "types": ["node", "jest"]
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "tests"]
}
```

#### Configure Package Scripts

**package.json**:
```json
{
  "scripts": {
    "dev": "nodemon src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "test": "jest --coverage",
    "test:watch": "jest --watch",
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate dev",
    "prisma:studio": "prisma studio",
    "lint": "eslint src --ext .ts",
    "lint:fix": "eslint src --ext .ts --fix",
    "format": "prettier --write \"src/**/*.ts\""
  }
}
```

---

## Phase 2: Clean Architecture

### Phase 2: Clean Architecture Implementation

agentful strictly follows the layered architecture pattern. Here's how it implements each layer:

#### Layer 1: Repository Layer (Data Access)

**src/repositories/product.repository.ts**:
```typescript
import { PrismaClient, Product, Prisma } from '@prisma/client';
import { prisma } from '../config/database';

export class ProductRepository {
  /**
   * Find product by ID
   */
  async findById(id: string): Promise<Product | null> {
    return prisma.product.findUnique({
      where: { id },
      include: { category: true },
    });
  }

  /**
   * Find all products with filters
   */
  async findAll(params: {
    skip?: number;
    take?: number;
    where?: Prisma.ProductWhereInput;
    orderBy?: Prisma.ProductOrderByWithRelationInput;
  }): Promise<Product[]> {
    const { skip = 0, take = 20, where, orderBy } = params;

    return prisma.product.findMany({
      skip,
      take,
      where,
      orderBy: orderBy || { createdAt: 'desc' },
      include: { category: true },
    });
  }

  /**
   * Count products matching criteria
   */
  async count(where?: Prisma.ProductWhereInput): Promise<number> {
    return prisma.product.count({ where });
  }

  /**
   * Create new product
   */
  async create(data: Prisma.ProductCreateInput): Promise<Product> {
    return prisma.product.create({
      data,
      include: { category: true },
    });
  }

  /**
   * Update product
   */
  async update(id: string, data: Prisma.ProductUpdateInput): Promise<Product> {
    return prisma.product.update({
      where: { id },
      data,
      include: { category: true },
    });
  }

  /**
   * Delete product
   */
  async delete(id: string): Promise<Product> {
    return prisma.product.delete({
      where: { id },
    });
  }

  /**
   * Check if product exists
   */
  async exists(id: string): Promise<boolean> {
    const count = await prisma.product.count({ where: { id } });
    return count > 0;
  }

  /**
   * Update product stock
   */
  async updateStock(id: string, quantity: number): Promise<Product> {
    return prisma.product.update({
      where: { id },
      data: { stock: { increment: quantity } },
    });
  }

  /**
   * Search products by name or description
   */
  async search(query: string, limit: number = 20): Promise<Product[]> {
    return prisma.product.findMany({
      where: {
        OR: [
          { name: { contains: query, mode: 'insensitive' } },
          { description: { contains: query, mode: 'insensitive' } },
        ],
      },
      take: limit,
      include: { category: true },
    });
  }
}
```

#### Layer 2: Service Layer (Business Logic)

**src/services/product.service.ts**:
```typescript
import { ProductRepository } from '../repositories/product.repository';
import { CategoryRepository } from '../repositories/category.repository';
import { ConflictError, NotFoundError, ValidationError } from '../utils/error';
import { Decimal } from '@prisma/client/runtime/library';

export interface CreateProductInput {
  name: string;
  description?: string;
  price: number;
  stock: number;
  categoryId: string;
  images?: string[];
}

export interface UpdateProductInput {
  name?: string;
  description?: string;
  price?: number;
  stock?: number;
  categoryId?: string;
  images?: string[];
}

export interface ProductQueryParams {
  page?: number;
  limit?: number;
  categoryId?: string;
  minPrice?: number;
  maxPrice?: number;
  search?: string;
  sortBy?: 'price' | 'name' | 'createdAt';
  sortOrder?: 'asc' | 'desc';
}

export class ProductService {
  private productRepo: ProductRepository;
  private categoryRepo: CategoryRepository;

  constructor() {
    this.productRepo = new ProductRepository();
    this.categoryRepo = new CategoryRepository();
  }

  /**
   * Get paginated list of products
   */
  async getProducts(query: ProductQueryParams) {
    const page = query.page || 1;
    const limit = Math.min(query.limit || 20, 100); // Max 100 per page
    const skip = (page - 1) * limit;

    // Build where clause
    const where: any = {};

    if (query.categoryId) {
      where.categoryId = query.categoryId;
    }

    if (query.minPrice !== undefined || query.maxPrice !== undefined) {
      where.price = {};
      if (query.minPrice !== undefined) where.price.gte = query.minPrice;
      if (query.maxPrice !== undefined) where.price.lte = query.maxPrice;
    }

    if (query.search) {
      where.OR = [
        { name: { contains: query.search, mode: 'insensitive' } },
        { description: { contains: query.search, mode: 'insensitive' } },
      ];
    }

    // Build order by
    const orderBy: any = {};
    if (query.sortBy) {
      orderBy[query.sortBy] = query.sortOrder || 'asc';
    } else {
      orderBy.createdAt = 'desc';
    }

    // Fetch products and total count
    const [products, total] = await Promise.all([
      this.productRepo.findAll({ skip, take: limit, where, orderBy }),
      this.productRepo.count(where),
    ]);

    return {
      data: products,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  /**
   * Get single product by ID
   */
  async getProductById(id: string) {
    const product = await this.productRepo.findById(id);

    if (!product) {
      throw new NotFoundError('Product not found');
    }

    return product;
  }

  /**
   * Create new product
   */
  async createProduct(input: CreateProductInput) {
    // Validate category exists
    const category = await this.categoryRepo.findById(input.categoryId);
    if (!category) {
      throw new NotFoundError('Category not found');
    }

    // Validate price
    if (input.price <= 0) {
      throw new ValidationError('Price must be greater than 0');
    }

    // Validate stock
    if (input.stock < 0) {
      throw new ValidationError('Stock cannot be negative');
    }

    // Create product
    const product = await this.productRepo.create({
      name: input.name,
      description: input.description,
      price: input.price,
      stock: input.stock,
      categoryId: input.categoryId,
      images: input.images || [],
    });

    return product;
  }

  /**
   * Update product
   */
  async updateProduct(id: string, input: UpdateProductInput) {
    // Check if product exists
    const existing = await this.productRepo.findById(id);
    if (!existing) {
      throw new NotFoundError('Product not found');
    }

    // Validate category if provided
    if (input.categoryId) {
      const category = await this.categoryRepo.findById(input.categoryId);
      if (!category) {
        throw new NotFoundError('Category not found');
      }
    }

    // Validate price if provided
    if (input.price !== undefined && input.price <= 0) {
      throw new ValidationError('Price must be greater than 0');
    }

    // Validate stock if provided
    if (input.stock !== undefined && input.stock < 0) {
      throw new ValidationError('Stock cannot be negative');
    }

    // Update product
    const product = await this.productRepo.update(id, input);

    return product;
  }

  /**
   * Delete product
   */
  async deleteProduct(id: string) {
    // Check if product exists
    const existing = await this.productRepo.findById(id);
    if (!existing) {
      throw new NotFoundError('Product not found');
    }

    // TODO: Check if product is referenced in any orders
    // For now, we'll allow deletion

    await this.productRepo.delete(id);

    return { message: 'Product deleted successfully' };
  }

  /**
   * Search products
   */
  async searchProducts(query: string, limit: number = 20) {
    if (!query || query.trim().length < 2) {
      throw new ValidationError('Search query must be at least 2 characters');
    }

    const products = await this.productRepo.search(query.trim(), limit);

    return {
      query,
      count: products.length,
      data: products,
    };
  }
}
```

#### Layer 3: Controller Layer (HTTP Handlers)

**src/controllers/product.controller.ts**:
```typescript
import { Request, Response, NextFunction } from 'express';
import { ProductService } from '../services/product.service';
import { asyncHandler } from '../utils/async-handler';
import { ProductQueryParams } from '../types/product.types';

export class ProductController {
  private productService: ProductService;

  constructor() {
    this.productService = new ProductService();
  }

  /**
   * GET /api/products
   * Get list of products with pagination and filters
   */
  getProducts = asyncHandler(async (req: Request, res: Response) => {
    const query: ProductQueryParams = {
      page: req.query.page ? parseInt(req.query.page as string) : undefined,
      limit: req.query.limit ? parseInt(req.query.limit as string) : undefined,
      categoryId: req.query.categoryId as string,
      minPrice: req.query.minPrice ? parseFloat(req.query.minPrice as string) : undefined,
      maxPrice: req.query.maxPrice ? parseFloat(req.query.maxPrice as string) : undefined,
      search: req.query.search as string,
      sortBy: req.query.sortBy as any,
      sortOrder: req.query.sortOrder as any,
    };

    const result = await this.productService.getProducts(query);

    res.json({
      success: true,
      ...result,
    });
  });

  /**
   * GET /api/products/:id
   * Get single product by ID
   */
  getProductById = asyncHandler(async (req: Request, res: Response) => {
    const { id } = req.params;

    const product = await this.productService.getProductById(id);

    res.json({
      success: true,
      data: product,
    });
  });

  /**
   * POST /api/products
   * Create new product (admin only)
   */
  createProduct = asyncHandler(async (req: Request, res: Response) => {
    const input = {
      name: req.body.name,
      description: req.body.description,
      price: req.body.price,
      stock: req.body.stock,
      categoryId: req.body.categoryId,
      images: req.body.images,
    };

    const product = await this.productService.createProduct(input);

    res.status(201).json({
      success: true,
      data: product,
    });
  });

  /**
   * PUT /api/products/:id
   * Update product (admin only)
   */
  updateProduct = asyncHandler(async (req: Request, res: Response) => {
    const { id } = req.params;
    const input = {
      name: req.body.name,
      description: req.body.description,
      price: req.body.price,
      stock: req.body.stock,
      categoryId: req.body.categoryId,
      images: req.body.images,
    };

    const product = await this.productService.updateProduct(id, input);

    res.json({
      success: true,
      data: product,
    });
  });

  /**
   * DELETE /api/products/:id
   * Delete product (admin only)
   */
  deleteProduct = asyncHandler(async (req: Request, res: Response) => {
    const { id } = req.params;

    await this.productService.deleteProduct(id);

    res.json({
      success: true,
      message: 'Product deleted successfully',
    });
  });

  /**
   * GET /api/products/search/:query
   * Search products
   */
  searchProducts = asyncHandler(async (req: Request, res: Response) => {
    const { query } = req.params;
    const limit = req.query.limit ? parseInt(req.query.limit as string) : 20;

    const result = await this.productService.searchProducts(query, limit);

    res.json({
      success: true,
      ...result,
    });
  });
}
```

#### Layer 4: Routes (Endpoint Definition)

**src/routes/product.routes.ts**:
```typescript
import { Router } from 'express';
import { ProductController } from '../controllers/product.controller';
import { authenticate, authorize } from '../middleware/auth.middleware';
import { validate } from '../middleware/validation.middleware';
import { productSchema, productQuerySchema } from '../schemas/product.schema';

const router = Router();
const controller = new ProductController();

// Public routes
router.get('/', validate(productQuerySchema, 'query'), controller.getProducts);
router.get('/search/:query', controller.searchProducts);
router.get('/:id', controller.getProductById);

// Admin routes
router.post(
  '/',
  authenticate,
  authorize('ADMIN', 'SUPERADMIN'),
  validate(productSchema),
  controller.createProduct
);

router.put(
  '/:id',
  authenticate,
  authorize('ADMIN', 'SUPERADMIN'),
  validate(productSchema),
  controller.updateProduct
);

router.delete(
  '/:id',
  authenticate,
  authorize('ADMIN', 'SUPERADMIN'),
  controller.deleteProduct
);

export default router;
```

---

## Phase 3: Testing

### Phase 3: Comprehensive Testing

agentful achieves 91% test coverage through unit and integration tests.

#### Unit Tests

**tests/unit/services/product.service.test.ts**:
```typescript
import { describe, it, expect, beforeEach, vi } from '@jest/globals';
import { ProductService } from '../../../src/services/product.service';
import { ProductRepository } from '../../../src/repositories/product.repository';
import { CategoryRepository } from '../../../src/repositories/category.repository';
import { NotFoundError, ValidationError } from '../../../src/utils/error';

// Mock repositories
vi.mock('../../../src/repositories/product.repository');
vi.mock('../../../src/repositories/category.repository');

describe('ProductService', () => {
  let productService: ProductService;
  let mockProductRepo: any;
  let mockCategoryRepo: any;

  beforeEach(() => {
    // Clear all mocks before each test
    vi.clearAllMocks();

    // Create service instance
    productService = new ProductService();

    // Get mock instances
    mockProductRepo = ProductRepository.prototype;
    mockCategoryRepo = CategoryRepository.prototype;
  });

  describe('getProducts', () => {
    it('should return paginated products', async () => {
      const mockProducts = [
        { id: '1', name: 'Product 1', price: 10 },
        { id: '2', name: 'Product 2', price: 20 },
      ];

      vi.spyOn(mockProductRepo, 'findAll').mockResolvedValue(mockProducts);
      vi.spyOn(mockProductRepo, 'count').mockResolvedValue(2);

      const result = await productService.getProducts({ page: 1, limit: 10 });

      expect(result.data).toEqual(mockProducts);
      expect(result.pagination).toEqual({
        page: 1,
        limit: 10,
        total: 2,
        totalPages: 1,
      });
    });

    it('should filter by category', async () => {
      vi.spyOn(mockProductRepo, 'findAll').mockResolvedValue([]);
      vi.spyOn(mockProductRepo, 'count').mockResolvedValue(0);

      await productService.getProducts({ categoryId: 'cat-123' });

      expect(mockProductRepo.findAll).toHaveBeenCalledWith(
        expect.objectContaining({
          where: expect.objectContaining({
            categoryId: 'cat-123',
          }),
        })
      );
    });

    it('should filter by price range', async () => {
      vi.spyOn(mockProductRepo, 'findAll').mockResolvedValue([]);
      vi.spyOn(mockProductRepo, 'count').mockResolvedValue(0);

      await productService.getProducts({ minPrice: 10, maxPrice: 100 });

      expect(mockProductRepo.findAll).toHaveBeenCalledWith(
        expect.objectContaining({
          where: expect.objectContaining({
            price: { gte: 10, lte: 100 },
          }),
        })
      );
    });

    it('should search by name or description', async () => {
      vi.spyOn(mockProductRepo, 'findAll').mockResolvedValue([]);
      vi.spyOn(mockProductRepo, 'count').mockResolvedValue(0);

      await productService.getProducts({ search: 'laptop' });

      expect(mockProductRepo.findAll).toHaveBeenCalledWith(
        expect.objectContaining({
          where: expect.objectContaining({
            OR: [
              { name: { contains: 'laptop', mode: 'insensitive' } },
              { description: { contains: 'laptop', mode: 'insensitive' } },
            ],
          }),
        })
      );
    });
  });

  describe('getProductById', () => {
    it('should return product if found', async () => {
      const mockProduct = { id: '1', name: 'Product 1', price: 10 };

      vi.spyOn(mockProductRepo, 'findById').mockResolvedValue(mockProduct);

      const result = await productService.getProductById('1');

      expect(result).toEqual(mockProduct);
    });

    it('should throw NotFoundError if product not found', async () => {
      vi.spyOn(mockProductRepo, 'findById').mockResolvedValue(null);

      await expect(productService.getProductById('999')).rejects.toThrow(
        NotFoundError
      );
      await expect(productService.getProductById('999')).rejects.toThrow(
        'Product not found'
      );
    });
  });

  describe('createProduct', () => {
    it('should create product with valid input', async () => {
      const input = {
        name: 'New Product',
        price: 99.99,
        stock: 10,
        categoryId: 'cat-123',
      };

      const mockCategory = { id: 'cat-123', name: 'Electronics' };
      const mockProduct = { id: '1', ...input };

      vi.spyOn(mockCategoryRepo, 'findById').mockResolvedValue(mockCategory);
      vi.spyOn(mockProductRepo, 'create').mockResolvedValue(mockProduct);

      const result = await productService.createProduct(input);

      expect(result).toEqual(mockProduct);
      expect(mockCategoryRepo.findById).toHaveBeenCalledWith('cat-123');
      expect(mockProductRepo.create).toHaveBeenCalled();
    });

    it('should throw error if category not found', async () => {
      const input = {
        name: 'New Product',
        price: 99.99,
        stock: 10,
        categoryId: 'invalid-cat',
      };

      vi.spyOn(mockCategoryRepo, 'findById').mockResolvedValue(null);

      await expect(productService.createProduct(input)).rejects.toThrow(
        NotFoundError
      );
      await expect(productService.createProduct(input)).rejects.toThrow(
        'Category not found'
      );
    });

    it('should throw error if price is invalid', async () => {
      const input = {
        name: 'New Product',
        price: -10,
        stock: 10,
        categoryId: 'cat-123',
      };

      vi.spyOn(mockCategoryRepo, 'findById').mockResolvedValue({ id: 'cat-123' });

      await expect(productService.createProduct(input)).rejects.toThrow(
        ValidationError
      );
      await expect(productService.createProduct(input)).rejects.toThrow(
        'Price must be greater than 0'
      );
    });

    it('should throw error if stock is negative', async () => {
      const input = {
        name: 'New Product',
        price: 99.99,
        stock: -5,
        categoryId: 'cat-123',
      };

      vi.spyOn(mockCategoryRepo, 'findById').mockResolvedValue({ id: 'cat-123' });

      await expect(productService.createProduct(input)).rejects.toThrow(
        ValidationError
      );
      await expect(productService.createProduct(input)).rejects.toThrow(
        'Stock cannot be negative'
      );
    });
  });

  describe('searchProducts', () => {
    it('should search products with valid query', async () => {
      const mockProducts = [
        { id: '1', name: 'Laptop Pro', description: 'High-end laptop' },
      ];

      vi.spyOn(mockProductRepo, 'search').mockResolvedValue(mockProducts);

      const result = await productService.searchProducts('laptop', 20);

      expect(result.query).toBe('laptop');
      expect(result.count).toBe(1);
      expect(result.data).toEqual(mockProducts);
    });

    it('should throw error if query is too short', async () => {
      await expect(productService.searchProducts('a', 20)).rejects.toThrow(
        ValidationError
      );
      await expect(productService.searchProducts('a', 20)).rejects.toThrow(
        'Search query must be at least 2 characters'
      );
    });

    it('should trim query string', async () => {
      vi.spyOn(mockProductRepo, 'search').mockResolvedValue([]);

      await productService.searchProducts('  laptop  ', 20);

      expect(mockProductRepo.search).toHaveBeenCalledWith('laptop', 20);
    });
  });
});
```

#### Integration Tests

**tests/integration/api/products.test.ts**:
```typescript
import { describe, it, expect, beforeAll, afterAll } from '@jest/globals';
import request from 'supertest';
import { app } from '../../../src/app';
import { prisma } from '../../../src/config/database';
import { generateToken } from '../../../src/config/jwt';

describe('POST /api/products', () => {
  let adminToken: string;
  let categoryId: string;

  beforeAll(async () => {
    // Create test category
    const category = await prisma.category.create({
      data: { name: 'Test Category' },
    });
    categoryId = category.id;

    // Create admin user and get token
    const admin = await prisma.user.create({
      data: {
        email: 'admin@test.com',
        password: 'hashed_password',
        name: 'Admin',
        role: 'ADMIN',
      },
    });
    adminToken = generateToken(admin.id, admin.role);
  });

  afterAll(async () => {
    // Cleanup
    await prisma.product.deleteMany({});
    await prisma.category.deleteMany({});
    await prisma.user.deleteMany({});
  });

  it('should create product as admin', async () => {
    const response = await request(app)
      .post('/api/products')
      .set('Authorization', `Bearer ${adminToken}`)
      .send({
        name: 'Test Product',
        description: 'Test description',
        price: 99.99,
        stock: 10,
        categoryId,
      });

    expect(response.status).toBe(201);
    expect(response.body.success).toBe(true);
    expect(response.body.data).toHaveProperty('id');
    expect(response.body.data.name).toBe('Test Product');
    expect(response.body.data.price).toBe('99.99');
  });

  it('should require authentication', async () => {
    const response = await request(app).post('/api/products').send({
      name: 'Test Product',
      price: 99.99,
      categoryId,
    });

    expect(response.status).toBe(401);
  });

  it('should require admin role', async () => {
    // Create customer user
    const customer = await prisma.user.create({
      data: {
        email: 'customer@test.com',
        password: 'hashed_password',
        name: 'Customer',
        role: 'CUSTOMER',
      },
    });
    const customerToken = generateToken(customer.id, customer.role);

    const response = await request(app)
      .post('/api/products')
      .set('Authorization', `Bearer ${customerToken}`)
      .send({
        name: 'Test Product',
        price: 99.99,
        categoryId,
      });

    expect(response.status).toBe(403);
  });

  it('should validate required fields', async () => {
    const response = await request(app)
      .post('/api/products')
      .set('Authorization', `Bearer ${adminToken}`)
      .send({
        name: 'Test Product',
        // Missing price, stock, categoryId
      });

    expect(response.status).toBe(400);
    expect(response.body.success).toBe(false);
    expect(response.body.error).toHaveProperty('details');
  });
});

describe('GET /api/products', () => {
  let products: any[];

  beforeAll(async () => {
    // Create test data
    const category = await prisma.category.create({
      data: { name: 'Electronics' },
    });

    products = await Promise.all([
      prisma.product.create({
        data: {
          name: 'Laptop',
          price: 999.99,
          stock: 10,
          categoryId: category.id,
        },
      }),
      prisma.product.create({
        data: {
          name: 'Mouse',
          price: 29.99,
          stock: 50,
          categoryId: category.id,
        },
      }),
    ]);
  });

  afterAll(async () => {
    await prisma.product.deleteMany({});
    await prisma.category.deleteMany({});
  });

  it('should return list of products', async () => {
    const response = await request(app).get('/api/products');

    expect(response.status).toBe(200);
    expect(response.body.success).toBe(true);
    expect(response.body.data).toHaveLength(2);
    expect(response.body.pagination).toHaveProperty('total');
  });

  it('should support pagination', async () => {
    const response = await request(app).get('/api/products?page=1&limit=1');

    expect(response.status).toBe(200);
    expect(response.body.data).toHaveLength(1);
    expect(response.body.pagination.page).toBe(1);
    expect(response.body.pagination.limit).toBe(1);
  });

  it('should filter by category', async () => {
    const response = await request(app)
      .get('/api/products')
      .query({ categoryId: products[0].categoryId });

    expect(response.status).toBe(200);
    expect(response.body.data.length).toBeGreaterThan(0);
  });

  it('should filter by price range', async () => {
    const response = await request(app)
      .get('/api/products')
      .query({ minPrice: 50, maxPrice: 1000 });

    expect(response.status).toBe(200);
    response.body.data.forEach((product: any) => {
      const price = parseFloat(product.price);
      expect(price).toBeGreaterThanOrEqual(50);
      expect(price).toBeLessThanOrEqual(1000);
    });
  });
});
```

---



---

## Results

### Development Time

| Phase | Duration | Agent |
|-------|----------|-------|
| Project Setup | 20 min | @orchestrator |
| Database Schema | 25 min | @backend |
| Authentication System | 1 hour | @backend + @tester |
| Product Catalog | 1.5 hours | @backend + @tester |
| Order Management | 1 hour | @backend + @tester |
| Category Management | 45 min | @backend + @tester |
| API Documentation | 40 min | @backend |
| **Total** | **5 hours** | |

### Code Metrics

```
Files Created: 87 files
- Repository layer: 5 files
- Service layer: 5 files
- Controller layer: 4 files
- Routes: 5 files
- Middleware: 4 files
- Schemas: 4 files
- Tests: 38 files
- Configuration: 12 files

Total Lines of Code: ~6,200 lines
- Application code: ~4,100 lines
- Test code: ~2,100 lines

Test Coverage: 91%
- Unit tests: 94% coverage
- Integration tests: 89% coverage

Quality Gates Status:
✅ All tests passing (312 tests)
✅ No type errors (adapts to stack)
✅ No ESLint errors
✅ Coverage threshold met (91% ≥ 80%)
✅ No dead code
✅ No security vulnerabilities
✅ API documentation complete
```

### API Performance

```
Endpoint Performance (p95):
- GET /api/products: 45ms
- GET /api/products/:id: 12ms
- POST /api/products: 67ms
- PUT /api/products/:id: 58ms
- DELETE /api/products/:id: 34ms
- POST /api/auth/login: 23ms
- POST /api/orders: 89ms

Load Testing:
- 1000 concurrent requests: All successful
- Average response time: 38ms
- Throughput: 26,316 requests/sec
- Error rate: 0%
```

---

## API Documentation

### Swagger UI Integration

The API includes self-documenting Swagger UI available at `/api-docs`.

**Example Swagger Spec**:
```yaml
openapi: 3.0.0
info:
  title: ShopAPI
  version: 1.0.0
  description: E-commerce REST API

paths:
  /api/products:
    get:
      summary: Get list of products
      tags: [Products]
      parameters:
        - name: page
          in: query
          schema:
            type: integer
            default: 1
        - name: limit
          in: query
          schema:
            type: integer
            default: 20
        - name: categoryId
          in: query
          schema:
            type: string
        - name: search
          in: query
          schema:
            type: string
      responses:
        '200':
          description: List of products
          content:
            application/json:
              schema:
                type: object
                properties:
                  success:
                    type: boolean
                  data:
                    type: array
                    items:
                      $ref: '#/components/schemas/Product'
                  pagination:
                    $ref: '#/components/schemas/Pagination'

    post:
      summary: Create new product
      tags: [Products]
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateProductInput'
      responses:
        '201':
          description: Product created
        '401':
          description: Unauthorized
        '403':
          description: Forbidden - Admin only

components:
  schemas:
    Product:
      type: object
      properties:
        id:
          type: string
        name:
          type: string
        description:
          type: string
        price:
          type: number
          format: decimal
        stock:
          type: integer
        categoryId:
          type: string

    Pagination:
      type: object
      properties:
        page:
          type: integer
        limit:
          type: integer
        total:
          type: integer
        totalPages:
          type: integer

  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
```

---

## Key Decisions

### Decision 1: Database Choice
**Question**: PostgreSQL vs MongoDB?
**Decision**: PostgreSQL
**Reasoning**:
- Relational data fits the domain (users, products, orders)
- ACID transactions critical for orders
- Strong typing with Prisma
- Better for complex queries

### Decision 2: Architecture Pattern
**Question**: MVC vs Clean Architecture?
**Decision**: Clean Architecture (Repository → Service → Controller)
**Reasoning**:
- Better separation of concerns
- Easier to test (mock repositories)
- More maintainable as codebase grows
- Business logic independent of frameworks

### Decision 3: Authentication Strategy
**Question**: Session vs JWT?
**Decision**: JWT
**Reasoning**:
- Stateless - no server-side session storage
- Works well for microservices (future scaling)
- Mobile app friendly
- Simple implementation

### Decision 4: Validation Library
**Question**: Joi vs Zod vs Yup?
**Decision**: Zod
**Reasoning**:
- TypeScript-first (infers types from schemas)
- Zero dependencies
- Better performance
- Excellent error messages

---

## Best Practices Demonstrated

### 1. Layer Separation
Each layer has a single responsibility:
- **Repository**: Data access only
- **Service**: Business logic only
- **Controller**: HTTP handling only

### 2. Dependency Injection
Services receive repositories as constructor parameters:
```typescript
constructor(productRepo: ProductRepository) {
  this.productRepo = productRepo;
}
```

### 3. Error Handling
Custom error classes with proper HTTP status codes:
```typescript
export class NotFoundError extends AppError {
  constructor(message: string) {
    super(message, 404, 'NOT_FOUND');
  }
}
```

### 4. Input Validation
All inputs validated before processing:
```typescript
const validated = productSchema.parse(req.body);
```

### 5. Transaction Management
Database operations wrapped in transactions:
```typescript
await prisma.$transaction(async (tx) => {
  // Multiple operations
  // All or nothing
});
```

---

## Conclusion

This API service demonstrates agentful's ability to:

- Build production-grade backends
- Follow clean architecture principles
- Achieve exceptional test coverage (91%)
- Implement comprehensive security
- Create self-documenting APIs
- Deliver in 5 hours (vs 2+ weeks traditionally)

**Perfect for**: Backend-focused projects, microservices, API-first applications

**Previous**: [Full-Stack App Example](/examples/full-stack-app)
**Next**: [Frontend Project Example](/examples/frontend-project)
